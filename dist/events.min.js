/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

const { MinHeap } = __webpack_require__(13);
const { MaxHeap } = __webpack_require__(14);
const { CustomHeap } = __webpack_require__(15);

exports.MinHeap = MinHeap;
exports.MaxHeap = MaxHeap;
exports.CustomHeap = CustomHeap;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 *
 * @class
 * @abstract
 */
class Heap {
  /**
   * Creates a heap instance
   * @param {array<string|number|object>} nodes
   * @param {string|number|object} [leaf]
   * @returns {number}
   */
  constructor(nodes, leaf) {
    this._nodes = Array.isArray(nodes) ? nodes : [];
    this._leaf = leaf || null;
  }

  /**
   * Checks if a parent has a left child
   * @private
   * @param {number} parentIndex
   * @returns {boolean}
   */
  _hasLeftChild(parentIndex) {
    const leftChildIndex = (parentIndex * 2) + 1;
    return leftChildIndex < this.size();
  }

  /**
   * Checks if a parent has a right child
   * @private
   * @param {number} parentIndex
   * @returns {boolean}
   */
  _hasRightChild(parentIndex) {
    const rightChildIndex = (parentIndex * 2) + 2;
    return rightChildIndex < this.size();
  }

  /**
   * Returns heap node's key
   * @private
   * @param {object|number|string} node
   * @returns {number|string}
   */
  _getKey(node) {
    if (typeof node === 'object') return node.key;
    return node;
  }

  /**
   * Swaps two nodes in the heap
   * @private
   * @param {number} i
   * @param {number} j
   */
  _swap(i, j) {
    const temp = this._nodes[i];
    this._nodes[i] = this._nodes[j];
    this._nodes[j] = temp;
  }

  /**
   * Compares parent & child nodes
   * and returns true if they are in right positions
   *
   * @private
   * @param {object|number|string} parent
   * @param {object|number|string} child
   * @returns {boolean}
   */
  _compare(parentNode, childNode) {
    return this._compareKeys(
      this._getKey(parentNode),
      this._getKey(childNode)
    );
  }

  /**
   * Checks if parent and child nodes should be swapped
   * @private
   * @param {number} parentIndex
   * @param {number} childIndex
   * @returns {boolean}
   */
  _shouldSwap(parentIndex, childIndex) {
    if (parentIndex < 0 || parentIndex >= this.size()) return false;
    if (childIndex < 0 || childIndex >= this.size()) return false;

    return !this._compare(
      this._nodes[parentIndex],
      this._nodes[childIndex]
    );
  }

  /**
   * Bubbles a node from a starting index up in the heap
   * @param {number} startingIndex
   * @public
   */
  heapifyUp(startingIndex) {
    let childIndex = startingIndex;
    let parentIndex = Math.floor((childIndex - 1) / 2);

    while (this._shouldSwap(parentIndex, childIndex)) {
      this._swap(parentIndex, childIndex);
      childIndex = parentIndex;
      parentIndex = Math.floor((childIndex - 1) / 2);
    }
  }

  /**
   * Compares left and right & children of a parent
   * @private
   * @param {number} parentIndex
   * @returns {number} - a child's index
   */
  _compareChildrenOf(parentIndex) {
    if (
      !this._hasLeftChild(parentIndex)
      && !this._hasRightChild(parentIndex)
    ) {
      return -1;
    }

    const leftChildIndex = (parentIndex * 2) + 1;
    const rightChildIndex = (parentIndex * 2) + 2;

    if (!this._hasLeftChild(parentIndex)) {
      return rightChildIndex;
    }

    if (!this._hasRightChild(parentIndex)) {
      return leftChildIndex;
    }

    const isLeft = this._compare(
      this._nodes[leftChildIndex],
      this._nodes[rightChildIndex]
    );

    return isLeft ? leftChildIndex : rightChildIndex;
  }

  /**
   * Pushes a node from a starting index down in the heap
   * @private
   */
  _heapifyDown(startingIndex) {
    let parentIndex = startingIndex;
    let childIndex = this._compareChildrenOf(parentIndex);

    while (this._shouldSwap(parentIndex, childIndex)) {
      this._swap(parentIndex, childIndex);
      parentIndex = childIndex;
      childIndex = this._compareChildrenOf(parentIndex);
    }
  }

  /**
   * Removes and returns the root node in the heap
   * @public
   * @returns {object}
   */
  extractRoot() {
    if (this.isEmpty()) return null;

    const root = this.root();
    this._nodes[0] = this._nodes[this.size() - 1];
    this._nodes.pop();
    this._heapifyDown(0);

    if (root === this._leaf) {
      this._leaf = this.root();
    }

    return root;
  }

  /**
   * Pushes a node with down in the heap before an index
   * @private
   * @param {number} index
   */
  _heapifyDownUntil(index) {
    let parentIndex = 0;
    let leftChildIndex = 1;
    let rightChildIndex = 2;
    let childIndex;

    while (leftChildIndex < index) {
      childIndex = this._compareChildrenBefore(
        index,
        leftChildIndex,
        rightChildIndex
      );

      if (this._shouldSwap(parentIndex, childIndex)) {
        this._swap(parentIndex, childIndex);
      }

      parentIndex = childIndex;
      leftChildIndex = (parentIndex * 2) + 1;
      rightChildIndex = (parentIndex * 2) + 2;
    }
  }

  /**
   * Returns a shallow copy of the heap
   * @protected
   * @param {class} HeapType
   * @returns {Heap}
   */
  _clone(HeapType) {
    return new HeapType(this._nodes.slice(), this._leaf);
  }

  /**
   * Sorts the heap by swapping root with all nodes and fixing positions
   * @public
   * @returns {array} the sorted nodes
   */
  sort() {
    for (let i = this.size() - 1; i > 0; i -= 1) {
      this._swap(0, i);
      this._heapifyDownUntil(i);
    }

    return this._nodes;
  }

  /**
   * Inserts a node in the right position into the heap
   * @public
   * @param {number|string} key
   * @param {any} [value]
   * @returns {Heap}
   */
  insert(key, value) {
    const newNode = value !== undefined ? { key, value } : key;
    this._nodes.push(newNode);
    this.heapifyUp(this.size() - 1);
    if (this._leaf === null || !this._compare(newNode, this._leaf)) {
      this._leaf = newNode;
    }
    return this;
  }

  /**
   * Fixes all positions of the nodes in the heap
   * @public
   * @returns {Heap}
   */
  fix() {
    for (let i = 0; i < this.size(); i += 1) {
      this.heapifyUp(i);
    }
    return this;
  }

  /**
   * Verifies that the heap is valid
   * @public
   * @returns {boolean}
   */
  isValid() {
    const isValidRecursive = (parentIndex) => {
      let isValidLeft = true;
      let isValidRight = true;

      if (this._hasLeftChild(parentIndex)) {
        const leftChildIndex = (parentIndex * 2) + 1;
        isValidLeft = this._compare(
          this._nodes[parentIndex],
          this._nodes[leftChildIndex]
        );

        if (!isValidLeft) {
          return false;
        }

        isValidLeft = isValidRecursive(leftChildIndex);
      }

      if (this._hasRightChild(parentIndex)) {
        const rightChildIndex = (parentIndex * 2) + 2;
        isValidRight = this._compare(
          this._nodes[parentIndex],
          this._nodes[rightChildIndex]
        );

        if (!isValidRight) {
          return false;
        }

        isValidRight = isValidRecursive(rightChildIndex);
      }

      return isValidLeft && isValidRight;
    };

    return isValidRecursive(0);
  }

  /**
   * Returns the root node in the heap
   * @public
   * @returns {object|number|string|null}
   */
  root() {
    if (this.isEmpty()) return null;
    return this._nodes[0];
  }

  /**
   * Returns a leaf node in the heap
   * @public
   * @returns {object|number|string|null}
   */
  leaf() {
    return this._leaf;
  }

  /**
   * Returns the number of nodes in the heap
   * @public
   * @returns {number}
   */
  size() {
    return this._nodes.length;
  }

  /**
   * Checks if the heap is empty
   * @public
   * @returns {boolean}
   */
  isEmpty() {
    return this.size() === 0;
  }

  /**
   * Clears the heap
   * @public
   */
  clear() {
    this._nodes = [];
    this._leaf = null;
  }

  /**
   * Convert a list of items into a heap
   * @protected
   * @static
   * @param {array} array
   * @param {class} HeapType
   * @returns {Heap}
   */
  static _heapify(list, HeapType) {
    if (!Array.isArray(list)) {
      throw new Error('.heapify expects an array');
    }

    return new HeapType(list).fix();
  }

  /**
   * Checks if a list of items is a valid heap
   * @protected
   * @static
   * @param {array} array
   * @param {class} HeapType
   * @returns {boolean}
   */
  static _isHeapified(list, HeapType) {
    return new HeapType(list).isValid();
  }
}

exports.Heap = Heap;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */

const { CustomHeap } = __webpack_require__(0);

/**
 * @class PriorityQueue
 */
class PriorityQueue {
  /**
   * Creates a priority queue
   * @public
   * @params {object} [options]
   */
  constructor(options = {}) {
    const { priority, compare } = options;
    if (compare) {
      if (typeof compare !== 'function') {
        throw new Error('.constructor expects a valid compare function');
      }
      this._compare = compare;
      this._heap = new CustomHeap(this._compare);
    } else {
      if (priority !== undefined && typeof priority !== 'function') {
        throw new Error('.constructor expects a valid priority function');
      }

      this._priority = priority || ((el) => +el);
    }
  }

  /**
   * @private
   * @returns {object}
   */
  _getElementWithPriority(node) {
    return {
      priority: node.key,
      element: node.value
    };
  }

  /**
   * @public
   * @returns {number}
   */
  size() {
    return this._heap.size();
  }

  /**
   * @public
   * @returns {boolean}
   */
  isEmpty() {
    return this._heap.isEmpty();
  }

  /**
   * Returns an element with highest priority in the queue
   * @public
   * @returns {object}
   */
  front() {
    if (this.isEmpty()) return null;

    if (this._compare) {
      return this._heap.root();
    }

    return this._getElementWithPriority(this._heap.root());
  }

  /**
   * Returns an element with lowest priority in the queue
   * @public
   * @returns {object}
   */
  back() {
    if (this.isEmpty()) return null;

    if (this._compare) {
      return this._heap.leaf();
    }

    return this._getElementWithPriority(this._heap.leaf());
  }

  /**
   * Adds an element to the queue
   * @public
   * @param {any} element
   * @param {number} p - priority
   * @throws {Error} if priority is not a valid number
   */
  enqueue(element, p) {
    if (this._compare) {
      this._heap.insert(element);
      return this;
    }

    if (p && Number.isNaN(+p)) {
      throw new Error('.enqueue expects a numeric priority');
    }

    if (Number.isNaN(+p) && Number.isNaN(this._priority(element))) {
      throw new Error(
        '.enqueue expects a numeric priority '
        + 'or a constructor callback that returns a number'
      );
    }

    const priority = !Number.isNaN(+p) ? p : this._priority(element);
    this._heap.insert(+priority, element);
    return this;
  }

  /**
   * Removes and returns an element with highest priority in the queue
   * @public
   * @returns {object}
   */
  dequeue() {
    if (this.isEmpty()) return null;

    if (this._compare) {
      return this._heap.extractRoot();
    }

    return this._getElementWithPriority(this._heap.extractRoot());
  }

  /**
   * Returns a sorted list of elements from highest to lowest priority
   * @public
   * @returns {array}
   */
  toArray() {
    if (this._compare) {
      return this._heap.clone().sort().reverse();
    }

    return this._heap
      .clone()
      .sort()
      .map((n) => this._getElementWithPriority(n))
      .reverse();
  }

  /**
   * Clears the queue
   * @public
   */
  clear() {
    this._heap.clear();
  }
}

exports.PriorityQueue = PriorityQueue;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(20);
} else {
  module.exports = require('./cjs/react.development.js');
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) {
  var ReactIs = require('react-is');

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(22)();
}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(7);

var _registerSlots = __webpack_require__(18);

var _registerSlots2 = _interopRequireDefault(_registerSlots);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _registerSlots2.default)();

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _data = __webpack_require__(8);

var _consonant = __webpack_require__(9);

// Build request: optionally switch to alternate endpoint
(0, _data.registerDataHook)('data.buildRequest', function (config) {
    var getCfg = (0, _consonant.makeConfigGetter)(config);
    var events = getCfg('events', '') || {};
    var useAlt = events && events.useAltEndpoint;
    var altEndpoint = events && events.altEndpoint;

    var endpoint = getCfg('collection', 'endpoint');
    if (useAlt && altEndpoint) endpoint = altEndpoint;

    var r = new RegExp('^(?:[a-z]+:)?//', 'i');
    var url = r.test(endpoint) ? new URL(endpoint) : new URL(endpoint, window.location.origin);
    return { url: url.toString(), options: { credentials: 'include' } };
});

// Map response: normalize to { cards, totalCount } when events.enabled
(0, _data.registerDataHook)('data.mapResponse', function (json, config) {
    var getCfg = (0, _consonant.makeConfigGetter)(config);
    var events = getCfg('events', '') || {};
    if (!events || !events.enabled) return json;

    var toCard = function toCard(item) {
        return {
            id: item.entityId || item.id,
            tags: (item.labels || item.tags || []).map(function (l) {
                return { id: l.id || l, title: l.name || String(l) };
            }),
            contentArea: {
                title: item.title || item.name,
                description: item.summary || item.description || '',
                dateTetailText: item.dateDetail || '',
                detailText: item.detailText || ''
            },
            overlays: {
                banner: { description: item.bannerText || '' }
            },
            startDate: item.session && item.session.start,
            endDate: item.session && item.session.end
        };
    };

    var results = json.results || json.items || [];
    return {
        cards: results.map(toCard),
        totalCount: json.total || results.length
    };
});

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.registerDataHook = registerDataHook;
exports.getDataHook = getDataHook;
// Simple data hook registry for pluggable request/response handling
var root = typeof window !== 'undefined' ? window : global;
// Create a shared global namespace so multiple bundles share hooks
var ns = root.CAAS_EXT || (root.CAAS_EXT = {});
if (!ns.dataHooks) ns.dataHooks = new Map();
var dataHooks = ns.dataHooks;
exports.dataHooks = dataHooks;
function registerDataHook(key, fn) {
    dataHooks.set(key, fn);
}

function getDataHook(key, defaultFn) {
    return dataHooks.get(key) || defaultFn;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeConfigGetter = exports.getNumSelectedFilterItems = undefined;
exports.getDefaultSortOption = getDefaultSortOption;

var _general = __webpack_require__(10);

var _constants = __webpack_require__(17);

/**
 * Gets the number of selected filter items
 * @param {Array} filters - filters array
 * @returns {Number} - the number of selected filter items
 */
var getNumSelectedFilterItems = exports.getNumSelectedFilterItems = function getNumSelectedFilterItems(filters) {
    var filterItems = (0, _general.chainFromIterable)(filters.map(function (filter) {
        return filter.items;
    }));
    return (0, _general.getSelectedItemsCount)(filterItems);
};

/**
 * Returns the authored or default configuration value
 * @param {Object} config - main configuration object
 * @returns {Object} - authored or default configuration value
 */
var makeConfigGetter = exports.makeConfigGetter = function makeConfigGetter(config) {
    return function (object, key) {
        var objectPath = key ? object + '.' + key : object;
        var defaultValue = (0, _general.getByPath)(_constants.DEFAULT_CONFIG, objectPath);

        var value = (0, _general.getByPath)(config, objectPath);

        if ((0, _general.isNullish)(value)) {
            return defaultValue;
        }
        return value;
    };
};

/**
 * Gets the sorting option to use
 * @param {Object} config - configuration object
 * @param {String} query - title of a sort option
 * @returns {Object} - Sort Option or default if none is found
 */
function getDefaultSortOption(config, query) {
    var getConfig = makeConfigGetter(config);
    var sortOptions = getConfig('sort', 'options');
    var sortConstant = _constants.SORT_TYPES[query.toUpperCase()];

    return sortOptions.find(function (option) {
        return option.sort === query;
    }) || {
        label: sortConstant || 'Featured',
        sort: sortConstant || 'featured'
    };
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.removeMarkDown = exports.sanitizeEventFilter = exports.getSearchParam = exports.getGlobalNavHeight = exports.getLinkTarget = exports.getEventBanner = exports.getCurrentDate = exports.isDateAfterInterval = exports.isDateBeforeInterval = exports.isDateWithinInterval = exports.qs = exports.mergeDeep = exports.setByPath = exports.debounce = exports.getSelectedItemsCount = exports.getByPath = exports.template = exports.getEndNumber = exports.getStartNumber = exports.getPageStartEnd = exports.generateRange = exports.stopPropagation = exports.isAtleastOneFilterSelected = exports.isNullish = exports.parseToPrimitive = exports.isObject = exports.mapObject = exports.sanitizeText = exports.sortByKey = exports.intersection = exports.isSuperset = exports.chainFromIterable = exports.chain = exports.removeDuplicatesByKey = exports.truncateList = exports.truncateString = exports.readInclusionsFromLocalStorage = exports.readBookmarksFromLocalStorage = exports.saveBookmarksToLocalStorage = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.getTransitions = getTransitions;

var _priorityQueue = __webpack_require__(11);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Saves a card to local storage
 * @param {Number} bookmarksValue - The id of the card to save
 * @return {Void}
 */
var saveBookmarksToLocalStorage = exports.saveBookmarksToLocalStorage = function saveBookmarksToLocalStorage(bookmarksValue) {
    localStorage.setItem('bookmarks', JSON.stringify(bookmarksValue, null, 2));
};

/**
 * Returns all cards saved in local storage
 * @return {Array} - All saved bookmarks
 */
var readBookmarksFromLocalStorage = exports.readBookmarksFromLocalStorage = function readBookmarksFromLocalStorage() {
    var bookmarks = JSON.parse(localStorage.getItem('bookmarks'));
    return Array.isArray(bookmarks) ? bookmarks : [];
};

var readInclusionsFromLocalStorage = exports.readInclusionsFromLocalStorage = function readInclusionsFromLocalStorage() {
    var favorites = JSON.parse(localStorage.getItem('chimera.favorites')) || [];
    var schedule = JSON.parse(localStorage.getItem('chimera.schedule')) || [];
    var lastWatched = localStorage.getItem('chimera.lastWatched') || '';

    return new Set([].concat(favorites, [lastWatched], schedule));
};

/**
 * Helper method to truncate strings
 * @param {String} str - The string to truncate
 * @param {Number} num - How much to truncate
 * @return {String} - The truncated string
 */
var truncateString = exports.truncateString = function truncateString(str, num) {
    if (str.length <= num) return str;
    return str.slice(0, num) + '...';
};

/**
 * Helper method to truncate a list of cards
 * @param {Number} limit - How much to truncate by
 * @param {Array} list - What to truncate
 * @return {Array} - The truncated list
 */
var truncateList = exports.truncateList = function truncateList(limit, list) {
    // No limit, return all;
    if (limit < 0) return list;

    // Slice received data to required q-ty;
    return list.slice(0, limit);
};

/**
 * Helper method to remove duplicate cards from list
 * @param {Array} list - The list of cards
 * @param {key} key - What key to search for duplicates for
 * @return {Array} - A list of cards with no duplicates
 */
var removeDuplicatesByKey = exports.removeDuplicatesByKey = function removeDuplicatesByKey(list, key) {
    var newList = [];
    var ids = new Set();
    list.forEach(function (item) {
        if (!ids.has(item[key])) {
            newList.push(item);
            ids.add(item[key]);
        }
    });
    return newList;
};

/**
 * Helper method that chains lists together
 * @param {Any} args - Any set of args
 * @example chain(['A', 'B', 'C'], ['D', 'E', 'F']) --> ['A' 'B' 'C' 'D' 'E' 'F']
 */
var chain = exports.chain = function chain() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    return args.reduce(function (a, b) {
        return a.concat(b);
    }, []);
};

/**
 * Helper method that chains iterables together
 * @param {Any} args - Any set of iterable arguments
 * @example chainFromIterable(someIterable) --> ['A' 'B' 'C' 'D' 'E' 'F']
 */
var chainFromIterable = exports.chainFromIterable = function chainFromIterable(args) {
    return chain.apply(undefined, _toConsumableArray(args));
};

/**
 * Helper method to determine wheether set A is a superset of set B
 * @param {Set} superset - The first set
 * @param {Set} subset - The second set
 * @return {Boolean} - Whether set A is a superset of set B
 */
var isSuperset = exports.isSuperset = function isSuperset(superset, subset) {
    // eslint-disable-next-line no-restricted-syntax
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = subset[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var elem = _step.value;

            if (!superset.has(elem)) {
                return false;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return true;
};

/**
 * Helper method to do determine whether the two sets have an intersection
 * @param {Set} setA - The first set
 * @param {Set} setB - The second set
 * @return {Boolean} - Whether there is an intersection of elements between the sets
 */
var intersection = exports.intersection = function intersection(setA, setB) {
    var intersectionSet = new Set();
    // eslint-disable-next-line no-restricted-syntax
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = setB[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var elem = _step2.value;

            if (setA.has(elem)) {
                intersectionSet.add(elem);
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return intersectionSet;
};

/**
 * Helper method to sort by keys
 * @param {Iterable} iterable - The iterable object
 * @param {Function} keyFunc - The function to apply
 */
var sortByKey = exports.sortByKey = function sortByKey(iterable, keyFunc) {
    return [].concat(_toConsumableArray(iterable)).sort(function (a, b) {
        if (keyFunc(a) < keyFunc(b)) return -1;
        if (keyFunc(a) > keyFunc(b)) return 1;
        return 0;
    });
};

var allowedChars = /[a-zA-Z0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s.]/g;

/**
 * Returns cleaned up text
 * don't allow urls
 * @param {String} text - The text so sanitize
 * @return {String} - The cleaned up text
 */
var sanitizeText = exports.sanitizeText = function sanitizeText(text) {
    if (!text) return '';
    var sanitized = text.toLowerCase().trim();
    // remove any invalid chars
    var matchedAllowedChars = sanitized.match(allowedChars);
    sanitized = matchedAllowedChars ? matchedAllowedChars.join('') : '';
    return sanitized;
};

/**
 * For a given object, applies a function to key in that object
 * @param {Object} object - The object to apply the function to
 * @param {Function} func - The function to apply to the entries in the object
 * @return {Object} - The new object
 */
var mapObject = exports.mapObject = function mapObject(object, func) {
    var newObj = {};
    var keys = Object.keys(object);

    keys.forEach(function (key) {
        newObj[key] = func(object[key]);
    });

    return newObj;
};

/**
 * Determines whether the passed in value is an object or not
 * @param {Any} val - Start value in the range array;
 * @return {Boolean} - Whether the passed in value is nullish or not
 */
var isObject = exports.isObject = function isObject(val) {
    return !!val && val.constructor === Object;
};

/**
 * Support method so HTL/Sightly can pass authored properties to React
 * @param {Object} value - Start value in the range array;
 * @return {Object} - Authored config used by react component
 */
var parseToPrimitive = exports.parseToPrimitive = function parseToPrimitive(value) {
    if (isObject(value)) {
        return mapObject(value, parseToPrimitive);
    } else if (Array.isArray(value)) {
        return value.map(parseToPrimitive);
    }

    try {
        return parseToPrimitive(JSON.parse(value));
    } catch (e) {
        return value;
    }
};

/**
 * Determines whether the passed in value is nullish or not
 * @param {Any} val - Start value in the range array;
 * @return {Boolean} - Whether the passed in value is nullish or not
 */
var isNullish = exports.isNullish = function isNullish(val) {
    return val === undefined || val === null || Number.isNaN(val);
};

var isAtleastOneFilterSelected = exports.isAtleastOneFilterSelected = function isAtleastOneFilterSelected(filters) {
    return chainFromIterable(filters.map(function (f) {
        return f.items;
    })).some(function (item) {
        return item.selected;
    });
};

/**
 * Helper method to stop propagation for events
 * @param {Event} e - The event to stop propagation for
 * @return {Void}
 */
var stopPropagation = exports.stopPropagation = function stopPropagation(e) {
    return e.stopPropagation();
};

/**
 * Return a range of numbers from [start, ... , end];
 * @param {number} startVal - Start value in the range array;
 * @param {number} end - End value in the range array;
 * @return {Array}
 */
var generateRange = exports.generateRange = function generateRange(startVal, end) {
    var start = startVal;
    var step = 1;
    var range = [];

    if (end < start) {
        step = -step;
    }

    while (step > 0 ? end >= start : end <= start) {
        range.push(start);
        start += step;
    }

    return range;
};

/**
 * Gets what start and end numbers should be for a given page
 * @param {number} pageCount - Total pages to display
 * @param {number} currentPageNumber - Current page user is on
 * @param {number} totalPages - Total number of pages available
 * @return {Array} - The start and end page numbers
 */
var getPageStartEnd = exports.getPageStartEnd = function getPageStartEnd(currentPageNumber, pageCount, totalPages) {
    var halfPageCount = Math.floor(pageCount / 2);
    var start = void 0;
    var end = void 0;

    if (totalPages <= pageCount + 1) {
        // show all pages
        start = 1;
        end = totalPages;
    } else {
        start = Math.min(Math.max(1, currentPageNumber - halfPageCount), totalPages - pageCount);
        end = Math.max(Math.min(currentPageNumber + halfPageCount, totalPages), pageCount + 1);
    }

    return [start, end];
};

/**
 * Gets the start number for Paginator Component
 * @param {Number} currentPageNumber - Current page the user is on
 * @param {Number} showItemsPerPage - How many items to show per page
 * @returns {Number} - The start number for Paginator Component
 */
var getStartNumber = exports.getStartNumber = function getStartNumber(currentPageNumber, showItemsPerPage) {
    if (currentPageNumber === 1) return 1;
    return currentPageNumber * showItemsPerPage - (showItemsPerPage - 1);
};

/**
 * Gets the end number for Paginator Component
 * @param {Number} currentPageNumber - Current page the user is on
 * @param {Number} showItemsPerPage - How many items to show per page
 * @param {Number} totalResults - Total count of cards in collection
 * @returns {Number} - The end number for Paginator Component
 */
var getEndNumber = exports.getEndNumber = function getEndNumber(currentPageNumber, showItemsPerPage, totalResults) {
    var res = currentPageNumber * showItemsPerPage;
    return res < totalResults ? res : totalResults;
};

/**
 * Gets the end number for Paginator Component
 * @param {string} text - template string like a '{0} {1}'
 * @param {object} props - object with props to replace part of text in brackets
 * @returns {string} - ('{placeholderKey}', { placeholderKey: 'placeholderValue' })
 *  => 'placeholderValue'
 */
var template = exports.template = function template() {
    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var props = arguments[1];

    if (!props) return text;

    var regExp = /{([A-z]*)}/gi;
    var replacer = function replacer(fullMatch, key) {
        return props[key] || fullMatch;
    };

    return text.replace(regExp, replacer);
};

/**
 * Gets the object/path/defaultValue and return object value by this path
 * @param {Object} object - object to get value
 * @param {String} path - path to searched value
 * @param {any} defaultValue - will return when no value was found
 * @returns {any} - searched value
 */
var getByPath = exports.getByPath = function getByPath(object, path, defaultValue) {
    if (!object || !path) return defaultValue;

    var result = object;
    var chunks = path.split('.');

    for (var index = 0; index < chunks.length; index += 1) {
        var chunk = chunks[index];

        /* eslint-disable-next-line no-prototype-builtins */
        if (result != null && result.hasOwnProperty(chunk)) {
            result = result[chunk];
        } else {
            result = defaultValue;
            break;
        }
    }

    return result;
};

/**
 * Return sum of the selected filters
 * @param {items} array - filter items
 * @returns {number} - selected items count
 */
var getSelectedItemsCount = exports.getSelectedItemsCount = function getSelectedItemsCount(items) {
    return items.filter(function (_ref) {
        var selected = _ref.selected;
        return Boolean(selected);
    }).length;
};

/**
 * Func to make debounced functions
 * @param {Function} func - target function
 * @param {number} timeout - debounce delay
 * @returns {func} - debounced function
 */
var debounce = exports.debounce = function debounce(func) {
    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var timer = void 0;

    return function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
        }

        clearTimeout(timer);

        timer = setTimeout(function () {
            func.apply(undefined, args);
        }, timeout);
    };
};

/**
 * Set object value by path
 * @param {Object} object - target object
 * @param {string} path - destination path
 * @param {any} value - value which should be assign
 */
var setByPath = exports.setByPath = function setByPath(object, path, value) {
    if (!object || !path) return;

    var chunks = path.split('.');
    var withoutLast = chunks.slice(0, -1);
    var lastChunk = chunks[chunks.length - 1];

    var target = withoutLast.reduce(function (accumulator, chunk) {
        if (!isObject(accumulator[chunk])) {
            accumulator[chunk] = {};
        }
        return accumulator[chunk];
    }, object);

    target[lastChunk] = value;
};

/**
 * Deep merge objects without undefined values
 * @param {Object} target - target object
 * @param {...Object} sources - objects to merge
 * @return {Obect} merge object
 */
var mergeDeep = exports.mergeDeep = function mergeDeep(target) {
    for (var _len3 = arguments.length, sources = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        sources[_key3 - 1] = arguments[_key3];
    }

    if (!sources.length) return target;

    var source = sources.shift();

    if (isObject(target) && isObject(source)) {
        var keys = Object.keys(source);

        keys.forEach(function (key) {
            if (isObject(source[key])) {
                if (!target[key]) target[key] = {};

                mergeDeep(target[key], source[key]);
            } else if (source[key] !== undefined) {
                Object.assign(target, _defineProperty({}, key, source[key]));
            }
        });
    }

    return mergeDeep.apply(undefined, [target].concat(sources));
};

var isCaasGroup = function isCaasGroup(group) {
    return group.indexOf('ch_') === 0;
};

/**
 * Methods to create/parse queryString
 */
var qs = exports.qs = {
    parse: function parse(string) {
        var searchParams = new URLSearchParams(string);

        return [].concat(_toConsumableArray(searchParams.keys())).reduce(function (accumulator, key) {
            if (!accumulator[key]) {
                var value = searchParams.getAll(key);

                if (isCaasGroup(key)) {
                    if (value.length === 1) {
                        var _value = value,
                            _value2 = _slicedToArray(_value, 1),
                            firstItem = _value2[0];
                        /* istanbul ignore if */


                        if (firstItem.includes('|')) {
                            value = firstItem.split('|');
                        }
                    }
                    accumulator[key] = decodeURIComponent(value);
                } else {
                    accumulator[key] = value;
                }
            }

            return accumulator;
        }, {});
    },
    stringify: function stringify(obj) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            array = _ref2.array;

        var searchParams = new URLSearchParams();
        Object.entries(obj).forEach(function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
                key = _ref4[0],
                value = _ref4[1];

            if (isCaasGroup(key)) {
                if (Array.isArray(value)) {
                    if (array === 'comma') {
                        searchParams.append(key, encodeURIComponent(value));
                    } else {
                        searchParams.append(key, encodeURIComponent(value.join('|')));
                    }
                } else {
                    searchParams.append(key, encodeURIComponent(value));
                }
            } else {
                searchParams.append(key, value);
            }
        });

        return searchParams.toString();
    }
};

var isDateWithinInterval = exports.isDateWithinInterval = function isDateWithinInterval(currentDate, startDate, endDate) {
    var curr = Date.parse(currentDate);
    var start = Date.parse(startDate);
    var end = Date.parse(endDate);

    return start <= curr && end > curr;
};

var isDateBeforeInterval = exports.isDateBeforeInterval = function isDateBeforeInterval(currentDate, startDate) {
    var curr = Date.parse(currentDate);
    var start = Date.parse(startDate);

    return curr < start;
};
/* istanbul ignore next */
var isDateAfterInterval = exports.isDateAfterInterval = function isDateAfterInterval(currentDate, endDate) {
    var curr = Date.parse(currentDate);
    var end = Date.parse(endDate);

    return curr > end;
};

var getCurrentDate = exports.getCurrentDate = function getCurrentDate() {
    var urlParams = new URLSearchParams(window.location.search);
    var servertime = parseInt(urlParams.get('servertime'), 10);
    var timeSinceArrival = performance.now();
    var currDate = servertime ? new Date(servertime + timeSinceArrival) : new Date();
    return currDate;
};

var getEventBanner = exports.getEventBanner = function foo(startDate, endDate, bannerMap) {
    var currDate = getCurrentDate();
    /* istanbul ignore if */
    if (isDateWithinInterval(currDate, startDate, endDate)) {
        return bannerMap.live || {
            backgroundColor: '',
            description: '',
            fontColor: '',
            icon: ''
        };
    } else if (isDateBeforeInterval(currDate, startDate)) {
        return bannerMap.upcoming || {
            backgroundColor: '',
            description: '',
            fontColor: '',
            icon: ''
        };
    }
    return bannerMap.onDemand || {
        backgroundColor: '',
        description: '',
        fontColor: '',
        icon: ''
    };
};

function getTransitions(cardsPtr) {
    var cards = [].concat(_toConsumableArray(cardsPtr));
    var currentDate = getCurrentDate();
    var transitions = new _priorityQueue.MinPriorityQueue();

    /* eslint-disable no-plusplus */
    for (var i = 0; i < cards.length; i++) {
        var priority = Date.parse(cards[i].startDate) - currentDate;
        /* istanbul ignore if */
        if (priority && priority > 0) {
            transitions.enqueue(cards[i], priority);
        }
        var endPriority = Date.parse(Date.parse(cards[i].endDate) - currentDate);
        /* istanbul ignore if */
        if (cards[i].endDate && endPriority > 0) {
            transitions.enqueue(null, endPriority);
        }
    }
    return transitions;
}

var getLinkTarget = exports.getLinkTarget = function getLinkTarget(link) {
    var ctaAction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var domain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window.location.hostname;

    if (ctaAction || link.startsWith('#')) {
        return ctaAction;
    }
    var target = '_blank';
    try {
        var _ref5 = new URL(link),
            _ref5$hostname = _ref5.hostname,
            linkHostName = _ref5$hostname === undefined ? '' : _ref5$hostname;

        if (domain === linkHostName) {
            target = '_self';
        }
    } catch (e) {
        /* eslint-disable-line no-empty */
    }
    return target;
};

var getGlobalNavHeight = exports.getGlobalNavHeight = function getGlobalNavHeight() {
    var header = document.querySelector('header');
    var offSet = 20; // margin above card collection
    /* istanbul ignore else */
    if (!header) return offSet;

    var isBacom = header.getAttribute('daa-lh') && header.getAttribute('daa-lh').includes('bacom');
    var headerWrapper = isBacom ? header : document.querySelector('.feds-header-wrapper');

    return isBacom || headerWrapper && headerWrapper.classList.contains('feds-header-wrapper--sticky') ? header.offsetHeight + offSet : offSet;
};

var getSearchParam = exports.getSearchParam = function getSearchParam(url, param) {
    if (!url || !url.startsWith('http') || !param) return null;
    var urlObj = new URL(url);
    return urlObj.searchParams.get(param);
};

var sanitizeEventFilter = exports.sanitizeEventFilter = function sanitizeEventFilter(rawEventFilter) {
    if (!rawEventFilter || rawEventFilter.indexOf('all') > -1) return [];
    if (Array.isArray(rawEventFilter)) return rawEventFilter;
    return [rawEventFilter];
};

var removeMarkDown = exports.removeMarkDown = function removeMarkDown() {
    var md = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    if (!md) return '';
    var text = md.toString() || '';
    return text.replace(/<[^>]*>/g, '').replaceAll('{**', '').replaceAll('**}', '').replaceAll('{*', '').replaceAll('*}', '');
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

const { MinPriorityQueue } = __webpack_require__(12);
const { MaxPriorityQueue } = __webpack_require__(16);
const { PriorityQueue } = __webpack_require__(2)

module.exports = { MinPriorityQueue, MaxPriorityQueue, PriorityQueue };


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */

const { MinHeap } = __webpack_require__(0);
const { PriorityQueue } = __webpack_require__(2);

/**
 * @class MinPriorityQueue
 * @extends PriorityQueue
 */
class MinPriorityQueue extends PriorityQueue {
  constructor(options) {
    super(options);
    if (!this._compare) {
      this._heap = new MinHeap();
    }
  }

  static from(entries) {
    const queue = new MinPriorityQueue();

    entries.forEach(([element, priority]) => {
      queue.enqueue(element, priority);
    });

    return queue;
  }
}

exports.MinPriorityQueue = MinPriorityQueue;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license MIT
 * @copyright 2019 Eyas Ranjous <eyas.ranjous@gmail.com>
 */

const { Heap } = __webpack_require__(1);

/**
 * @class MinHeap
 * @extends Heap
 */
class MinHeap extends Heap {
  /**
   * Checks two nodes are in relatively valid position
   * @private
   * @param {object} parent
   * @param {object} child
   * @returns {boolean}
   */
  _compareKeys(parentKey, childKey) {
    return parentKey < childKey;
  }

  /**
   * Returns min child's index of two children before an index
   * @protected
   * @param {number} index
   * @param {number} leftChildIndex
   * @param {number} rightChildIndex
   * @returns {number}
   */
  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {
    const leftChildKey = this._getKey(this._nodes[leftChildIndex]);
    const rightChildKey = this._getKey(this._nodes[rightChildIndex]);

    if (rightChildKey < leftChildKey && rightChildIndex < index) {
      return rightChildIndex;
    }
    return leftChildIndex;
  }

  /**
   * Returns a shallow copy of the heap
   * @public
   * @returns {MinHeap}
   */
  clone() {
    return super._clone(MinHeap);
  }

  /**
   * Builds a min heap from an array of items
   * @public
   * @static
   * @param {array} list
   * @returns {MinHeap}
   */
  static heapify(list) {
    return super._heapify(list, MinHeap);
  }

  /**
   * Checks if a list of list is a valid min heap
   * @public
   * @static
   * @param {array} list
   * @returns {boolean}
   */
  static isHeapified(list) {
    return super._isHeapified(list, MinHeap);
  }
}

exports.MinHeap = MinHeap;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 */

const { Heap } = __webpack_require__(1);

/**
 * @class MaxHeap
 * @extends Heap
 */
class MaxHeap extends Heap {
  /**
   * Checks two nodes are in relatively valid position
   * @private
   * @param {object} parent
   * @param {object} child
   * @returns {boolean}
   */
  _compareKeys(parentKey, childKey) {
    return parentKey > childKey;
  }

  /**
   * Returns max child's index of two children before an index
   * @private
   * @param {number} index
   * @param {number} leftChildIndex
   * @param {number} rightChildIndex
   * @returns {number}
   */
  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {
    const leftChildKey = this._getKey(this._nodes[leftChildIndex]);
    const rightChildKey = this._getKey(this._nodes[rightChildIndex]);

    if (rightChildKey > leftChildKey && rightChildIndex < index) {
      return rightChildIndex;
    }
    return leftChildIndex;
  }

  /**
   * Returns a shallow copy of the heap
   * @public
   * @returns {MaxHeap}
   */
  clone() {
    return super._clone(MaxHeap);
  }

  /**
   * Builds a max heap from an array of items
   * @public
   * @static
   * @param {array} list
   * @returns {MaxHeap}
   */
  static heapify(list) {
    return super._heapify(list, MaxHeap);
  }

  /**
   * Checks if a list of items is a valid max heap
   * @public
   * @static
   * @param {array} list
   * @returns {boolean}
   */
  static isHeapified(list) {
    return super._isHeapified(list, MaxHeap);
  }
}

exports.MaxHeap = MaxHeap;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 */

const { Heap } = __webpack_require__(1);

/**
 * @class CustomHeap
 * @extends Heap
 */
class CustomHeap extends Heap {
  constructor(comparator, nodes, leaf) {
    if (typeof comparator !== 'function') {
      throw new Error('CustomHeap expects a comparator function');
    }
    super(nodes, leaf);
    this._comparator = comparator;
  }

  /**
   * Compares parent & child nodes
   * and returns true if they are in right positions
   *
   * @private
   * @param {object|number|string} parent
   * @param {object|number|string} child
   * @returns {number}
   */
  _compare(parentNode, childNode) {
    return this._comparator(parentNode, childNode) <= 0;
  }

  /**
   * Returns child's index of two children before an index
   * @private
   * @param {number} index
   * @param {number} leftChildIndex
   * @param {number} rightChildIndex
   * @returns {number}
   */
  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {
    const compare = this._comparator(
      this._nodes[rightChildIndex],
      this._nodes[leftChildIndex]
    );

    if (compare <= 0 && rightChildIndex < index) {
      return rightChildIndex;
    }

    return leftChildIndex;
  }

  /**
   * Returns a shallow copy of the heap
   * @public
   * @returns {CustomHeap}
   */
  clone() {
    return new CustomHeap(
      this._comparator,
      this._nodes.slice(),
      this._leaf
    );
  }

  /**
   * Builds a custom heap from an array of items
   * @public
   * @static
   * @param {array} list
   * @param {function} comparator
   * @returns {CustomHeap}
   */
  static heapify(list, comparator) {
    if (!Array.isArray(list)) {
      throw new Error('.heapify expects an array');
    }

    if (typeof comparator !== 'function') {
      throw new Error('.heapify expects a comparator function');
    }

    return new CustomHeap(comparator, list).fix();
  }

  /**
   * Checks if a list of items is a valid custom heap
   * @public
   * @static
   * @param {array} list
   * @param {function} comparator
   * @returns {boolean}
   */
  static isHeapified(list, comparator) {
    if (!Array.isArray(list)) {
      throw new Error('.heapify expects an array');
    }

    if (typeof comparator !== 'function') {
      throw new Error('.isHeapified expects a comparator function');
    }

    return new CustomHeap(comparator, list).isValid();
  }
}

exports.CustomHeap = CustomHeap;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */

const { MaxHeap } = __webpack_require__(0);
const { PriorityQueue } = __webpack_require__(2);

/**
 * @class MaxPriorityQueue
 * @extends PriorityQueue
 */
class MaxPriorityQueue extends PriorityQueue {
  constructor(options) {
    super(options);
    if (!this._compare) {
      this._heap = new MaxHeap();
    }
  }

  static from(entries) {
    const queue = new MaxPriorityQueue();

    entries.forEach(([element, priority]) => {
      queue.enqueue(element, priority);
    });

    return queue;
  }
}

exports.MaxPriorityQueue = MaxPriorityQueue;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Minimal viewport width to fit desktops/laptops
 * @type {Number}
 */
var DESKTOP_MIN_WIDTH = exports.DESKTOP_MIN_WIDTH = 1200;

/**
 * Minimal viewport width to fit tablets
 * @type {Number}
 */
var TABLET_MIN_WIDTH = exports.TABLET_MIN_WIDTH = 768;

/**
 * Maximum allowed top filters displayed
 * before "More Filters" button shows up
 * @type {Number}
 */
var MAX_TRUNCATED_FILTERS = exports.MAX_TRUNCATED_FILTERS = 3;

/**
 * Minimum top filters needed to display blurred effect
 * on filters wrapper
 * @type {Number}
 */
var MIN_FILTERS_SHOW_BG = exports.MIN_FILTERS_SHOW_BG = 3;

/**
 * Maximum allowed card description length
 * after which a truncation will take place
 * @type {Number}
 */
var TRUNCATE_TEXT_QTY = exports.TRUNCATE_TEXT_QTY = 200;

/**
 * Quantity of the pagination items to display
 * for mobile and desktop breakpoints
 * @type {Object}
 */
var PAGINATION_COUNT = exports.PAGINATION_COUNT = {
    DESKTOP: 10,
    MOBILE: 4
};

/**
 * Available filtering types
 * @type {Object}
 */
var FILTER_TYPES = exports.FILTER_TYPES = {
    AND: 'and',
    OR: 'or',
    XOR: 'xor'
};

/**
 * Available filter panel types
 * @type {Object}
 */
var FILTER_PANEL = exports.FILTER_PANEL = {
    LEFT: 'left',
    TOP: 'top',
    EVENTS: 'events'
};

/**
 * Available sorting types
 * @type {Object}
 */
var SORT_TYPES = exports.SORT_TYPES = {
    DATEASC: 'dateasc',
    DATEDESC: 'datedesc',
    MODIFIEDDESC: 'modifieddesc',
    MODIFIEDASC: 'modifiedasc',
    EVENTSORT: 'eventsort',
    FEATURED: 'featured',
    TITLEASC: 'titleasc',
    TITLEDESC: 'titledesc',
    RANDOM: 'random'
};

var EVENT_TIMING_IDS = exports.EVENT_TIMING_IDS = {
    LIVE: '8as8/hafk',
    ONDEMAND: '8as8/hyb6',
    UPCOMING: '8as8/iabx'
};

/**
 * Possible Locations of the Sort Popup
 * @type {String}
 */
var SORT_POPUP_LOCATION = exports.SORT_POPUP_LOCATION = {
    LEFT: 'left',
    RIGHT: 'right'
};

/**
 * Available infobit types
 * @type {Object}
 */
var INFOBIT_TYPE = exports.INFOBIT_TYPE = {
    PRICE: 'price',
    BUTTON: 'button',
    ICON_TEXT: 'icon-with-text',
    LINK_ICON: 'link-with-icon',
    TEXT: 'text',
    ICON: 'icon',
    LINK: 'link',
    PROGRESS: 'progress-bar',
    RATING: 'rating',
    BOOKMARK: 'bookmark',
    DATE: 'date-interval',
    GATED: 'gated'
};

/**
 * Available themes class names
 * @type {Object}
 */
var THEME_TYPE = exports.THEME_TYPE = {
    LIGHT: 'light',
    DARK: 'dark',
    DARKEST: 'darkest'
};

/**
 * Default authoring constants
 * @type {Object}
 */
var DEFAULT_CONFIG = exports.DEFAULT_CONFIG = {
    collection: {
        mode: '',
        layout: {
            type: '3up',
            gutter: '4x',
            container: '32Margin'
        },
        button: {
            style: ''
        },
        resultsPerPage: 9,
        endpoint: '',
        title: '',
        totalCardLimit: -1,
        cardStyle: '',
        bladeCard: {
            reverse: false,
            lightText: false,
            transparent: false
        },
        displayTotalResults: true,
        totalResultsText: '{} results',
        i18n: {
            prettyDateIntervalFormat: '{LLL} {dd} | {timeRange} {timeZone}',
            totalResultsText: '{total} results',
            title: '',
            onErrorTitle: 'Sorry there was a system error.',
            onErrorDescription: 'Please try reloading the page or try coming back to the page another time.',
            sortByAria: 'Sort by {key}',
            removeFilterAria: 'Remove {filter} filter',
            removeAllFiltersAria: 'Remove {num} {filter} filters',
            playVideo: 'Play, {cardTitle}'
        }
    },
    featuredCards: [],
    hideCtaIds: [],
    hideCtaTags: [],
    header: {
        enabled: false
    },
    filterPanel: {
        enabled: true,
        eventFilter: '',
        type: 'left',
        filters: [],
        clearAllFiltersText: 'Clear all',
        clearFilterText: 'Clear',
        filterLogic: 'and',
        leftPanelHeader: 'Refine the results',
        topPanel: {
            mobile: {
                blurFilters: true
            }
        }
    },
    sort: {
        enabled: true,
        defaultSort: 'featured',
        options: []
    },
    pagination: {
        enabled: true,
        type: 'loadMore',
        loadMoreButton: {
            style: 'primary',
            useThemeThree: false
        },
        paginatorQuantityText: 'Showing {}-{} of {} Results',
        paginatorPrevLabel: 'Previous',
        paginatorNextLabel: 'Next',
        loadMoreButtonText: 'Load more',
        loadMoreQuantityText: '{} of {} displayed'
    },
    bookmarks: {
        enabled: true,
        bookmarkOnlyCollection: false,
        cardSavedIcon: '',
        cardUnsavedIcon: '',
        selectBookmarksIcon: '',
        unselectBookmarksIcon: '',
        saveCardText: 'Save card',
        unsaveCardText: 'Unsave card',
        bookmarksFilterTitle: 'My favorites'
    },
    search: {
        enabled: true,
        inputPlaceholderText: 'Search here...',
        leftPanelTitle: 'Search',
        searchFields: ['title', 'description'],
        i18n: {
            noResultsTitle: 'No results found',
            noResultsDescription: 'We couldn\u2019t find any results for your {query}.{break}\n            Check your spelling or try broadening your search.'
        }
    },
    language: 'en',
    headers: []
};

/**
 * Default number of cards to display per page
 * @type {Number}
 */
var DEFAULT_SHOW_ITEMS_PER_PAGE = exports.DEFAULT_SHOW_ITEMS_PER_PAGE = 8;

/**
 * Available card types
 * @type {Object}
 */
var CARD_STYLES = exports.CARD_STYLES = {
    CARD: 'card',
    CUSTOM: 'custom-card'
};

/**
 * Available grid types
 * @type {Object}
 */
var GRID_TYPE = exports.GRID_TYPE = {
    TWO_UP: '2up',
    THREE_UP: '3up',
    FOUR_UP: '4up',
    FIVE_UP: '5up'
};

/**
 * Available gutter sizes
 * @type {Object}
 */
var GUTTER_SIZE = exports.GUTTER_SIZE = {
    GUTTER_1_X: '1x',
    GUTTER_2_X: '2x',
    GUTTER_3_X: '3x',
    GUTTER_4_X: '4x'
};

/**
 * Available layout container types
 * @type {Object}
 */
var LAYOUT_CONTAINER = exports.LAYOUT_CONTAINER = {
    SIZE_83_VW: '83Percent',
    SIZE_1200_PX: '1200MaxWidth',
    SIZE_1600_PX: '1600MaxWidth',
    SIZE_100_VW_32_MARGIN: '32Margin',
    CAROUSEL: 'carousel',
    CATEGORIES: 'categories'
};

/**
 * Available loader sizes
 * @type {Object}
 */
var LOADER_SIZE = exports.LOADER_SIZE = {
    MEDIUM: 'medium',
    BIG: 'big'
};

/**
 * Used for lazy-loading - lets the lazy load of the image
 * start before it is scrolled into the viewport.
 * @type {String}
 */
var ROOT_MARGIN_DEFAULT = exports.ROOT_MARGIN_DEFAULT = '500px';
var ONE_SECOND_DELAY = exports.ONE_SECOND_DELAY = 1000;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = registerEventSlots;

var _registry = __webpack_require__(19);

var _MySessionsSection = __webpack_require__(24);

var _MySessionsSection2 = _interopRequireDefault(_MySessionsSection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function registerEventSlots() {
    (0, _registry.registerSlot)('filters:left:afterMyFavorites', _MySessionsSection2.default);
}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.slots = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /* eslint-disable */


exports.registerSlot = registerSlot;
exports.getSlotComponents = getSlotComponents;
exports.SlotRenderer = SlotRenderer;

var _react = __webpack_require__(4);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Slot registry to allow injecting UI components into predefined locations
var root = typeof window !== 'undefined' ? window : global;
var ns = root.CAAS_EXT || (root.CAAS_EXT = {});
if (!ns.slots) ns.slots = new Map();
var slots = ns.slots;
exports.slots = slots;


var SLOT_EVENT = 'CAAS_SLOTS_UPDATED';

function registerSlot(slotId, Component) {
    if (!slots.has(slotId)) slots.set(slotId, []);
    slots.get(slotId).push(Component);
    if (typeof window !== 'undefined' && window.dispatchEvent) {
        window.dispatchEvent(new CustomEvent(SLOT_EVENT, { detail: { slotId: slotId } }));
    }
}

function getSlotComponents(slotId) {
    return slots.get(slotId) || [];
}

function SlotRenderer(_ref) {
    var slotId = _ref.slotId,
        slotProps = _ref.slotProps;

    var _useState = (0, _react.useState)(0),
        _useState2 = _slicedToArray(_useState, 2),
        setTick = _useState2[1];

    (0, _react.useEffect)(function () {
        var handler = function handler(e) {
            if (!e || !e.detail) {
                setTick(function (t) {
                    return t + 1;
                });return;
            }
            if (!slotId || e.detail.slotId === slotId) setTick(function (t) {
                return t + 1;
            });
        };
        if (typeof window !== 'undefined' && window.addEventListener) {
            window.addEventListener(SLOT_EVENT, handler);
        }
        return function () {
            if (typeof window !== 'undefined' && window.removeEventListener) {
                window.removeEventListener(SLOT_EVENT, handler);
            }
        };
    }, [slotId]);

    var list = getSlotComponents(slotId);
    if (!list.length) return null;
    return _react2.default.createElement(
        _react2.default.Fragment,
        null,
        list.map(function (Comp, i) {
            return (
                // eslint-disable-next-line react/no-array-index-key
                _react2.default.createElement(Comp, _extends({ key: slotId + '-' + i }, slotProps))
            );
        })
    );
}

SlotRenderer.defaultProps = {
    slotProps: {}
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.14.0
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var l=__webpack_require__(21),n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.forward_ref"):60112,y=n?Symbol.for("react.suspense"):60113,z=n?Symbol.for("react.memo"):60115,A=n?Symbol.for("react.lazy"):
60116,B="function"===typeof Symbol&&Symbol.iterator;function C(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
var D={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E={};function F(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(C(85));this.updater.enqueueSetState(this,a,b,"setState")};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
function G(){}G.prototype=F.prototype;function H(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}var I=H.prototype=new G;I.constructor=H;l(I,F.prototype);I.isPureReactComponent=!0;var J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,c){var e,d={},g=null,k=null;if(null!=b)for(e in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,e)&&!L.hasOwnProperty(e)&&(d[e]=b[e]);var f=arguments.length-2;if(1===f)d.children=c;else if(1<f){for(var h=Array(f),m=0;m<f;m++)h[m]=arguments[m+2];d.children=h}if(a&&a.defaultProps)for(e in f=a.defaultProps,f)void 0===d[e]&&(d[e]=f[e]);return{$$typeof:p,type:a,key:g,ref:k,props:d,_owner:J.current}}
function N(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g,Q=[];function R(a,b,c,e){if(Q.length){var d=Q.pop();d.result=a;d.keyPrefix=b;d.func=c;d.context=e;d.count=0;return d}return{result:a,keyPrefix:b,func:c,context:e,count:0}}
function S(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>Q.length&&Q.push(a)}
function T(a,b,c,e){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return c(e,a,""===b?"."+U(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+U(d,k);g+=T(d,f,c,e)}else if(null===a||"object"!==typeof a?f=null:(f=B&&a[B]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),k=
0;!(d=a.next()).done;)d=d.value,f=b+U(d,k++),g+=T(d,f,c,e);else if("object"===d)throw c=""+a,Error(C(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return g}function V(a,b,c){return null==a?0:T(a,"",b,c)}function U(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function W(a,b){a.func.call(a.context,b,a.count++)}
function aa(a,b,c){var e=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?X(a,e,c,function(a){return a}):null!=a&&(O(a)&&(a=N(a,d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(P,"$&/")+"/")+c)),e.push(a))}function X(a,b,c,e,d){var g="";null!=c&&(g=(""+c).replace(P,"$&/")+"/");b=R(b,g,e,d);V(a,aa,b);S(b)}var Y={current:null};function Z(){var a=Y.current;if(null===a)throw Error(C(321));return a}
var ba={ReactCurrentDispatcher:Y,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:J,IsSomeRendererActing:{current:!1},assign:l};exports.Children={map:function(a,b,c){if(null==a)return a;var e=[];X(a,e,null,b,c);return e},forEach:function(a,b,c){if(null==a)return a;b=R(null,null,b,c);V(a,W,b);S(b)},count:function(a){return V(a,function(){return null},null)},toArray:function(a){var b=[];X(a,b,null,function(a){return a});return b},only:function(a){if(!O(a))throw Error(C(143));return a}};
exports.Component=F;exports.Fragment=r;exports.Profiler=u;exports.PureComponent=H;exports.StrictMode=t;exports.Suspense=y;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ba;
exports.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(C(267,a));var e=l({},a.props),d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=J.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)K.call(b,h)&&!L.hasOwnProperty(h)&&(e[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){f=Array(h);for(var m=0;m<h;m++)f[m]=arguments[m+2];e.children=f}return{$$typeof:p,type:a.type,
key:d,ref:g,props:e,_owner:k}};exports.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};exports.forwardRef=function(a){return{$$typeof:x,render:a}};exports.isValidElement=O;
exports.lazy=function(a){return{$$typeof:A,_ctor:a,_status:-1,_result:null}};exports.memo=function(a,b){return{$$typeof:z,type:a,compare:void 0===b?null:b}};exports.useCallback=function(a,b){return Z().useCallback(a,b)};exports.useContext=function(a,b){return Z().useContext(a,b)};exports.useDebugValue=function(){};exports.useEffect=function(a,b){return Z().useEffect(a,b)};exports.useImperativeHandle=function(a,b,c){return Z().useImperativeHandle(a,b,c)};
exports.useLayoutEffect=function(a,b){return Z().useLayoutEffect(a,b)};exports.useMemo=function(a,b){return Z().useMemo(a,b)};exports.useReducer=function(a,b,c){return Z().useReducer(a,b,c)};exports.useRef=function(a){return Z().useRef(a)};exports.useState=function(a){return Z().useState(a)};exports.version="16.14.0";


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(23);

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = MySessionsSection;

var _react = __webpack_require__(4);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MySessionsSection(_ref) {
    var selectedIds = _ref.selectedIds,
        applyFilter = _ref.applyFilter,
        events = _ref.events;

    var filterId = events && events.mySessions && events.mySessions.filterId;
    var itemId = events && events.mySessions && events.mySessions.itemId;
    var active = !!(itemId && selectedIds && selectedIds.includes(itemId));
    var toggle = function toggle() {
        if (filterId && itemId) {
            applyFilter(filterId, itemId, !active);
        }
    };
    return _react2.default.createElement(
        'section',
        {
            className: 'events-my-sessions',
            'data-testid': 'events-MySessionsSection' },
        _react2.default.createElement(
            'div',
            { className: 'title' },
            'My Sessions'
        ),
        _react2.default.createElement(
            'button',
            { type: 'button', onClick: toggle, className: 'consonant-Btn' },
            active ? 'Showing My Sessions' : 'Show My Sessions'
        )
    );
}

MySessionsSection.defaultProps = {
    selectedIds: [],
    events: {}
};

/***/ })
/******/ ]);